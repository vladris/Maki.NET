<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Templates\Common.t4" #>
<#@ output extension=".cs" #>
using Maki.Details;
using System;
using System.Diagnostics;

namespace Maki
{
<#
for (int types = 2; types <= 8; types++)
{
    var type = $"Variant<{JoinWithPrefix(types, "T")}>";
#>

    /// <summary>
    /// Represents a <#= types #>-type discriminate union.
    /// </summary>
<#
	for (int i = 1; i <= types; i++)
	{
#>
    /// <typeparam name="T<#= i #>">Represents the variant's <#= Ordinals[i] #> type.</typeparam>
<#
	}
#>
    public sealed class <#= type #> : VariantBase
    {
        private Variant(IVariantHolder item)
            : base(item)
        {}

<#
	for (int i = 1; i <= types; i++)
	{
#>
        /// <summary>
        /// Creates a new Variant instance from an item of type <typeparamref name="T<#= i #>"/>.
        /// </summary>
        /// <param name="item">Item of type <typeparamref name="T<#= i #>"/>.</param>
        public Variant(T<#= i #> item)
            : base(VariantHolder<T<#= i #>>.T<#= i #>(item))
        {}

<#
	}
#>
        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// </summary>
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns>True if the objects are equal.</returns>
        public override bool Equals(object obj)
        {
            if (obj == null || !(obj is <#= type #>)) return false;

            var other = (<#= type #>)obj;

            switch (Index)
            {
<#
	for (int i = 1; i <= types; i++)
	{
#>
            case <#= i - 1#>: return other.Index == <#= i -1 #> && Get<T<#= i #>>().Equals(other.Get<T<#= i#>>());
<#
	}
#>
            }

            Debug.Fail("Not reached");
            return false; 
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>Hash code.</returns>
        public override int GetHashCode()
        {
            switch (Index)
            {
<#
	for (int i = 1; i <= types; i++)
	{
#>
            case <#= i - 1#>: return Get<T<#= i #>>().GetHashCode();
<#
	}
#>
            }

            Debug.Fail("Not reached");
            return base.GetHashCode(); 
        }

<#
	for (int i = 1; i <= types; i++)
	{
#>
        /// <summary>
        /// Creates a new Variant explicitly placing the item as the <#= Ordinals[i] #> type
        /// (<typeparamref name="T<#= i #>"/>).
        /// </summary>
        /// <param name="item">Item to place in the variant.</param>
        /// <returns>New Variant instance.</returns>
        /// <remarks>Use this method when the variant contains multiple instances of the same type. This
        /// allows explicit placing of the item.</remarks>
        public static <#= type #> Make<#= i #>(T<#= i #> item) => new <#= type #>(VariantHolder<T<#= i #>>.T<#= i #>(item));

        /// <summary>
        /// Implicitly casts from <typeparamref name="T<#= i #>"/> to variant. Creates a new Variant
        /// inhabited by the given item.
        /// </summary>
        /// <param name="item">Item to store in the variant.</param>
        public static implicit operator <#= type #>(T<#= i #> item) => new <#= type #>(item);

        /// <summary>
        /// Explicitly casts from variant to <typeparamref name="T<#= i #>"/>.
        /// </summary>
        /// <param name="variant">Variant to cast to <typeparamref name="T<#= i #>"/>.</param>
        /// <exception cref="System.InvalidCastException">Thrown if the item inhabiting the variant is not of type <typenameref type="T<#= i #>"/></exception>
        public static explicit operator T<#= i #>(<#= type #> variant) => variant.Get<T<#= i #>>();

<#
	}
#>
    }
<#
}
#>
}