<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Templates\Common.t4" #>
<#@ output extension=".cs" #>
using Maki.Details;
using System;
using System.Diagnostics;

namespace Maki
{
<#
for (int types = 2; types <= 8; types++)
{
    var type = $"Variant<{JoinWithPrefix(types, "T")}>";
#>
    /// <summary>
    /// Represents a <#= types #>-type discriminate union.
    /// </summary>
<#
	for (int i = 1; i <= types; i++)
	{
#>
    /// <typeparam name="T<#= i #>">Represents the variant's <#= Ordinals[i] #> type.</typeparam>
<#
	}
#>
    public sealed class <#= type #>
    {
        private readonly IVariantHolder variant;

        /// <summary>
        /// Gets the 0-based index of the type inhabiting the variant.
        /// </summary>
        public int Index => variant.Index;

        /// <summary>
        /// Returns a value that indicates whether the variant is inhabited by an item of type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">Should be one of the variant's supplied types.</typeparam>
        /// <returns>True if the variant is inhabited by an item of type <typenameref type="T"/>, false otherwise.</returns>
        public bool Is<T>() => variant.Is<T>();

        /// <summary>
        /// Gets the item inhabiting the variant as a <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">Should be one of the variant's supplied types.</typeparam>
        /// <returns>Item inhabiting the variant as the given type <tpyenameref name="T"/>.</returns>
        /// <exception cref="InvalidCastException">Thrown if the item inhabiting the variant is not of type <typenameref type="T"/></exception>
        public T Get<T>() => Is<T>() ? ((VariantHolder<T>)variant).Item : throw new InvalidCastException();

        /// <summary>
        /// Gets the item inhabiting the variant as a dynamic object.
        /// </summary>
        /// <returns>Item inhabiting the variant as a dynamic object.</returns>
        public dynamic Get() => variant.GetDynamic();

        private Variant(IVariantHolder item) => variant = item;

<#
	for (int i = 1; i <= types; i++)
	{
#>
        /// <summary>
        /// Creates a new Variant instance from an item of type <typeparamref name="T<#= i #>"/>.
        /// </summary>
        /// <param name="item">Item of type <typeparamref name="T<#= i #>"/>.</param>
        public Variant(T<#= i #> item) => variant = VariantHolder<T<#= i #>>.T<#= i #>(item);

<#
	}
#>
        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// </summary>
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns>True if the objects are equal.</returns>
        public override bool Equals(object obj)
        {
            if (obj == null) return false;

            if (!(obj is <#= type #>)) return base.Equals(obj);

            var other = (<#= type #>)obj;

            switch (Index)
            {
<#
	for (int i = 1; i <= types; i++)
	{
#>
            case <#= i - 1#>:
                return other.Is<T<#= i #>>() && ((VariantHolder<T<#= i #>>)variant).Item.Equals(((VariantHolder<T<#= i #>>)other.variant).Item);
<#
	}
#>
            }

            Debug.Fail("Not reached");
            return false; 
        }

        /// <summary>
        /// Returns the hash code for this instance.
        /// </summary>
        /// <returns>Hash code.</returns>
        public override int GetHashCode()
        {
            switch (Index)
            {
<#
	for (int i = 1; i <= types; i++)
	{
#>
            case <#= i - 1#>: return ((VariantHolder<T<#= i #>>)variant).Item.GetHashCode();
<#
	}
#>
            }

            Debug.Fail("Not reached");
            return base.GetHashCode(); 
        }

<#
	for (int i = 1; i <= types; i++)
	{
#>
        /// <summary>
        /// Creates a new Variant explicitly placing the item as the <#= Ordinals[i] #> type
        /// (<typeparamref name="T<#= i #>"/>).
        /// </summary>
        /// <param name="item">Item to place in the variant.</param>
        /// <returns>New Variant instance.</returns>
        /// <remarks>Use this method when the variant contains multiple instances of the same type. This
        /// allows explicit placing of the item.</remarks>
        public static <#= type #> Make<#= i #>(T<#= i #> item) => new <#= type #>(VariantHolder<T<#= i #>>.T<#= i #>(item));

        /// <summary>
        /// Implicitly casts from <typeparamref name="T<#= i #>"/> to variant. Creates a new Variant
        /// inhabited by the given item.
        /// </summary>
        /// <param name="item">Item to store in the variant.</param>
        public static implicit operator <#= type #>(T<#= i #> item) => new <#= type #>(item);

        /// <summary>
        /// Explicitly casts from variant to <typeparamref name="T<#= i #>"/>.
        /// </summary>
        /// <param name="variant">Variant to cast to <typeparamref name="T<#= i #>"/>.</param>
        /// <exception cref="System.InvalidCastException">Thrown if the item inhabiting the variant is not of type <typenameref type="T<#= i #>"/></exception>
        public static explicit operator T<#= i #>(<#= type #> variant) => ((VariantHolder<T<#= i #>>)variant.variant).Item;

<#
	}
#>
    }
<#
}
#>
}